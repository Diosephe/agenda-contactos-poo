# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KVpQ3N8lXiNr5WGp6KUjR0NpUmU7F7JB
"""

# =========================
# Sistema de Gesti√≥n de Contactos (M√≥dulo 2)
# =========================

import unittest
# Yo importo unittest porque es una librer√≠a *est√°ndar* de Python (viene instalada)
# y me sirve para hacer pruebas unitarias, que el enunciado pide (y para que no me fallen cosas xd).

def normalizar_telefono(telefono: str) -> str:
    t = telefono.strip().replace(" ", "").replace("-", "")
    # strip() me saca espacios al inicio/final
    # replace() me borra espacios internos y guiones (para que "+56 9-1234 5678" quede "+56912345678")

    # permitimos un + al inicio
    # Yo permito que el tel√©fono venga con + (por ejemplo +56...), como formato internacional.
    if t.startswith("+"):
        base = t[1:]
        if not base.isdigit():
            # Si despu√©s del + hay letras o s√≠mbolos raros, lo considero inv√°lido.
            raise ValueError("Tel√©fono inv√°lido: despu√©s de '+' deben ir solo d√≠gitos.")
    else:
        # Si no hay +, entonces exijo que sean solo d√≠gitos.
        if not t.isdigit():
            raise ValueError("Tel√©fono inv√°lido: usa solo d√≠gitos (y opcional '+').")

    # Yo valido largo para evitar cosas demasiado cortas o demasiado largas.
    digitos = t[1:] if t.startswith("+") else t  # cuento d√≠gitos sin considerar el "+"
    if len(digitos) < 6 or len(digitos) > 15:
        raise ValueError("Tel√©fono inv√°lido: largo debe estar entre 6 y 15 d√≠gitos.")

    return t
def validar_correo(correo: str) -> str:
    # Esta funci√≥n la uso para validar el correo de forma simple.
    c = correo.strip()
    if "@" not in c or c.startswith("@") or c.endswith("@"):

        raise ValueError("Correo inv√°lido: debe contener '@' y texto a ambos lados.")
    return c

class Contacto:
    """Contacto con encapsulaci√≥n v√≠a atributos privados y properties."""
    # guardo atributos ‚Äúprivados‚Äù (_nombre, _telefono, etc.) y controlo cambios con setters.

    def __init__(self, contacto_id: int, nombre: str, telefono: str, correo: str, direccion: str):
        # Este es el constructor: se ejecuta cuando creo un Contacto.
        self._id = contacto_id  # id interno (yo no lo cambio despu√©s)

        # Ojo: aqu√≠ asigno usando properties (self.nombre, self.telefono, ...)
        # para que se apliquen las validaciones autom√°ticamente.
        self.nombre = nombre
        self.telefono = telefono
        self.correo = correo
        self.direccion = direccion

    @property
    def id(self) -> int:
        return self._id

    @property
    def nombre(self) -> str:
        return self._nombre

    @nombre.setter
    def nombre(self, value: str) -> None:
        # Setter del nombre: aqu√≠ valido y guardo.
        v = value.strip()
        if len(v) < 2:
            # Regla simple: nombre muy corto no sirve.
            raise ValueError("Nombre inv√°lido (muy corto).")
        self._nombre = v

    @property
    def telefono(self) -> str:
        return self._telefono

    @telefono.setter
    def telefono(self, value: str) -> None:
        self._telefono = normalizar_telefono(value)

    @property
    def correo(self) -> str:
        return self._correo

    @correo.setter
    def correo(self, value: str) -> None:
        self._correo = validar_correo(value)

    @property
    def direccion(self) -> str:
        return self._direccion

    @direccion.setter
    def direccion(self, value: str) -> None:
        v = value.strip()
        if v == "":
            raise ValueError("Direcci√≥n inv√°lida (vac√≠a).")
        self._direccion = v

    def to_dict(self) -> dict:
        # Yo convierto el contacto a diccionario para imprimir """""bonito""""" y/o exportar f√°cil.
        return {
            "id": self.id,
            "nombre": self.nombre,
            "telefono": self.telefono,
            "correo": self.correo,
            "direccion": self.direccion,
        }

    def __repr__(self) -> str:
        # Esto define c√≥mo se ‚Äúmuestra‚Äù el objeto si lo imprimo en consola (√∫til para debug jaja).
        return f"Contacto(id={self.id}, nombre='{self.nombre}', telefono='{self.telefono}')"


class AgendaContactos:
    """
    - Lista: guarda los contactos (para listar f√°cilmente)
    - Dict por ID: acceso r√°pido por id
    - Dict por tel√©fono: b√∫squeda r√°pida por tel√©fono y regla de unicidad
    """
    def __init__(self):
        # Aqu√≠ inicializo mi ‚Äúbase de datos‚Äù en memoria.
        self._contactos = []           # LISTA: ac√° guardo los Contacto en orden
        self._por_id = {}              # DICCIONARIO: id -> Contacto
        self._por_telefono = {}        # DICCIONARIO: telefono_normalizado -> id
        self._next_id = 1              # contador para generar IDs √∫nicos

    def agregar_contacto(self, nombre: str, telefono: str, correo: str, direccion: str) -> int:
        # Agrego un contacto nuevo y devuelvo su ID.
        tel = normalizar_telefono(telefono)
        if tel in self._por_telefono:
            # Regla: no permito dos contactos con el mismo tel√©fono.
            raise ValueError("Ya existe un contacto con ese tel√©fono.")

        cid = self._next_id      # asigno ID
        self._next_id += 1       # preparo el pr√≥ximo ID

        c = Contacto(cid, nombre, tel, correo, direccion)  # creo el objeto Contacto

        # Guardo en mis tres estructuras:
        self._contactos.append(c)      # lista (para listar)
        self._por_id[cid] = c          # dict por id (para acceso r√°pido)
        self._por_telefono[tel] = cid  # dict por tel√©fono (para b√∫squeda/duplicados)

        return cid
    def listar_contactos(self):
        # Devuelvo una copia de la lista para no exponer la lista interna directamente.
        return list(self._contactos)

    def obtener_contacto(self, contacto_id: int) -> Contacto:
        if contacto_id not in self._por_id:
            raise KeyError("No existe un contacto con ese ID.")
        return self._por_id[contacto_id]

    def buscar_por_nombre(self, texto: str):
        q = texto.strip().lower()
        return [c for c in self._contactos if q in c.nombre.lower()]

    def buscar_por_telefono(self, telefono: str):
        tel = normalizar_telefono(telefono)
        cid = self._por_telefono.get(tel)  # get devuelve None si no existe (sin explotar)
        return self._por_id.get(cid) if cid is not None else None

    def editar_contacto(self, contacto_id: int, nombre=None, telefono=None, correo=None, direccion=None) -> None:
        # Edito campos opcionales: si alguno viene como None, lo dejo tal cual.
        c = self.obtener_contacto(contacto_id)

        # Si cambia tel√©fono: chequear unicidad y actualizar √≠ndice
        if telefono is not None:
            nuevo_tel = normalizar_telefono(telefono)
            # Si el nuevo tel√©fono ya lo tiene otro contacto, no lo permito.
            if nuevo_tel != c.telefono and nuevo_tel in self._por_telefono:
                raise ValueError("Ya existe otro contacto con ese tel√©fono.")

            # actualizar diccionario por tel√©fono
            del self._por_telefono[c.telefono]  # borro el tel√©fono viejo del √≠ndice
            c.telefono = nuevo_tel              # actualizo el contacto (pasa por validaci√≥n)
            self._por_telefono[c.telefono] = c.id  # registro el tel√©fono nuevo en el √≠ndice

        # Los dem√°s campos se actualizan solo si vienen:
        if nombre is not None:
            c.nombre = nombre
        if correo is not None:
            c.correo = correo
        if direccion is not None:
            c.direccion = direccion

    def eliminar_contacto(self, contacto_id: int) -> None:
        # Elimino un contacto por ID.
        c = self.obtener_contacto(contacto_id)

        # borrar de diccionarios (para que no quede ‚Äúfantasma‚Äù en los √≠ndices)
        del self._por_id[contacto_id]
        del self._por_telefono[c.telefono]

        # borrar de la lista (b√∫squeda lineal simple)
        for i, item in enumerate(self._contactos):
            if item.id == contacto_id:
                self._contactos.pop(i)  # elimino por √≠ndice
                break


# ====== Men√∫ de consola ======
def ejecutar_menu():
    # Este men√∫ es el ‚Äúprototipo funcional‚Äù: lo uso para interactuar y demostrar el sistema en vivo.
    agenda = AgendaContactos()

    while True:
        # Yo uso while True para que el men√∫ se repita hasta que yo elija salir (modo infinito xd).
        print("\n=== Agenda de Contactos ===")
        print("1) Agregar")
        print("2) Listar")
        print("3) Buscar por nombre")
        print("4) Buscar por tel√©fono")
        print("5) Editar")
        print("6) Eliminar")
        print("0) Salir")

        op = input("Opci√≥n: ").strip()

        try:
            # Yo uso try/except para que si el usuario se equivoca (dato malo o ID inexistente),
            # el programa no se caiga: solo muestro el error y sigo.
            if op == "1":
                nombre = input("Nombre: ")
                telefono = input("Tel√©fono: ")
                correo = input("Correo: ")
                direccion = input("Direcci√≥n: ")
                cid = agenda.agregar_contacto(nombre, telefono, correo, direccion)
                print(f"‚úÖ Agregado con ID {cid}")

            elif op == "2":
                contactos = agenda.listar_contactos()
                if not contactos:
                    print("No hay contactos.")
                for c in contactos:
                    print(c.to_dict())  # imprimo en formato diccionario para que se vea ordenado

            elif op == "3":
                q = input("Texto del nombre: ")
                res = agenda.buscar_por_nombre(q)
                print(f"Resultados: {len(res)}")
                for c in res:
                    print(c.to_dict())

            elif op == "4":
                t = input("Tel√©fono exacto: ")
                c = agenda.buscar_por_telefono(t)
                print(c.to_dict() if c else "Sin resultados.")

            elif op == "5":
                cid = int(input("ID a editar: "))
                c = agenda.obtener_contacto(cid)

                print("Deja vac√≠o para mantener.")
                # Si el usuario deja vac√≠o, uso "or None" para que quede como None y as√≠ no edito ese campo.
                nombre = input(f"Nombre [{c.nombre}]: ").strip() or None
                telefono = input(f"Tel√©fono [{c.telefono}]: ").strip() or None
                correo = input(f"Correo [{c.correo}]: ").strip() or None
                direccion = input(f"Direcci√≥n [{c.direccion}]: ").strip() or None

                agenda.editar_contacto(cid, nombre=nombre, telefono=telefono, correo=correo, direccion=direccion)
                print("‚úÖ Editado.")

            elif op == "6":
                cid = int(input("ID a eliminar: "))
                agenda.eliminar_contacto(cid)
                print("üóëÔ∏è Eliminado.")

            elif op == "0":
                print("Chao üëã ...")
                break

            else:
                print("Opci√≥n inv√°lida...")

        except (ValueError, KeyError) as e:
            # ValueError: datos inv√°lidos (correo/tel√©fono/nombre)
            # KeyError: ID inexistente
            print(f"‚ùå Error: {e}")


# ====== Pruebas unitarias m√≠nimas (agregar + buscar) ======
class TestAgendaContactos(unittest.TestCase):
    # Esta clase de tests la uso para demostrar autom√°ticamente que el sistema funciona:
    # yo pruebo agregar y buscar (que son requisitos m√≠nimos).

    def setUp(self):
        # setUp se ejecuta antes de cada test: me deja una agenda ‚Äúlimpia‚Äù siempre.
        self.agenda = AgendaContactos()

    def test_agregar_contacto(self):
        # Test: agrego un contacto y verifico que el ID y el tama√±o queden bien.
        cid = self.agenda.agregar_contacto(
            "Yoseph Barrera", "+56912345678", "yoseph@mail.com", "Santiago"
        )
        self.assertEqual(cid, 1)
        self.assertEqual(len(self.agenda.listar_contactos()), 1)

    def test_buscar_por_nombre(self):
        # Test: busco por nombre (substring) y espero 1 resultado.
        self.agenda.agregar_contacto("Valenthina Perez", "+56911111111", "vale@mail.com", "Providencia")
        res = self.agenda.buscar_por_nombre("valen")
        self.assertEqual(len(res), 1)

    def test_buscar_por_telefono(self):
        self.agenda.agregar_contacto("Ana", "+56922222222", "ana@mail.com", "X")
        c = self.agenda.buscar_por_telefono("+56922222222")
        self.assertIsNotNone(c)
        self.assertEqual(c.nombre, "Ana")

# 1) Para correr los tests:
#    unittest.main(argv=[''], exit=False)
#
# 2) Para usar el men√∫ interactivo:
#    ejecutar_menu()